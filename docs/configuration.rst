Configuration
=============

``django-unasyncify``'s configuration should be placed within your project's ``pyproject.toml``, inthe ``[tool.django-unasyncify]`` section.

``unasync_helpers_path`` and ``unasync_helpers_import_path`` are both required configuration values.

.. confval:: paths_to_visit
   :type: ``list[str]``

   Lists paths to directories and files that should be scanned for code generation.


   .. code-block:: toml

        [tool.django_unasyncify]
        paths_to_visit = [
            "src/pkg1/foo.py"
            "src/pkg2",
        ]

   In the above configuration, we would check ``src/pkg1/foo.py`` and all ``.py`` files within ``src/pkg2``.


   By default ``paths_to_visit`` is set to ``["."]``, which will check all ``.py`` files in your project.

   While the unasyncify process on files is fairly quick, on larger projects it's a good idea to scope things down.

.. confval:: unasync_helpers_path
   :type: ``str``

   ``unasync_helpers_path`` is a string to a Python file that ``django-unasyncify`` manages, that includes the definitions to the :ref:`unasync-helpers`.

   A file will be created at the provided path that includes decorators used by ``django-unasyncify``. That way, code that is generated by ``django-unasyncify`` doesn't actually need to have ``django-unasyncify`` (or its requirements).

.. confval:: unasync_helpers_import_path
   :type: ``str``

   The import name that would be used to import the file indicated in ``unasync_helpers_path``. This should be a dotted path, and will be used to generate the right kind of ``import`` statements during code generation.

   .. code-block:: toml

      [tool.django-unasyncify]
      unasync_helpers_path = "src/pkg1/_codegen.py"
      unasync_helpers_import_path = "pkg1._codegen"


   In the above configuration, we'll end up with something like::

      frok pkg1._codegen import from_codegen, generate_unasynced

   After generation.


.. confval:: attribute_renames
   :type: ``dict[str, str]``

   In some cases you might want to rename certain identifiers based on whether it's the sync or async variant.

   For these cases you can use ``identifier_renames`` to definie a key/value mapping of these::

    [tool.django-unasyncify]
    identifier_renames = {
        aconnection = "connection",
        async_obj   = "sync_obj"
    }

   This renaming mapping will kick in during codegen for functions marked with ``@generate_unasynced``.

   It will replace usages of the identifer in attribute accesses. This is very helpful when dealing with attributes on ``self`` for an object that might manage both sync and async variations::

    mark_as_used(self.async_obj)
    return self.aconnection.properties

    # Becomes
    mark_as_used(self.sync_obj)
    return self.connection.properties


   This renaming is meant for attribute accesses. Async method call renaming happens automatically based on the norm of "removing the ``a``", and you mostly shouldn't need this.

   See :ref:`naming-scheme` and :ref:`handling-function-calls` for details on how method renaming happens.
